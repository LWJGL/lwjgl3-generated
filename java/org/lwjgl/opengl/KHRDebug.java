/*
 * Copyright LWJGL. All rights reserved.
 * License terms: http://lwjgl.org/license.php
 * MACHINE GENERATED FILE, DO NOT EDIT
 */
package org.lwjgl.opengl;

import org.lwjgl.*;
import org.lwjgl.system.*;

import java.nio.*;

import static org.lwjgl.system.Checks.*;
import static org.lwjgl.system.JNI.*;
import static org.lwjgl.system.MemoryUtil.*;
import static org.lwjgl.system.APIUtil.*;

/**
 * Native bindings to the <a href="http://www.opengl.org/registry/specs/KHR/debug.txt">KHR_debug</a> extension.
 * 
 * <p>This extension allows the GL to notify applications when various events occur that may be useful during application development, debugging and
 * profiling.</p>
 * 
 * <p>These events are represented in the form of enumerable messages with a human-readable string representation. Examples of debug events include incorrect
 * use of the GL, warnings of undefined behavior, and performance warnings.</p>
 * 
 * <p>A message is uniquely identified by a source, a type and an implementation-dependent ID within the source and type pair.</p>
 * 
 * <p>A message's source identifies the origin of the message and can either describe components of the GL, the window system, third-party external sources
 * such as external debuggers, or even the application itself.</p>
 * 
 * <p>The type of the message roughly identifies the nature of the event that caused the message. Examples include errors, performance warnings, warnings
 * about undefined behavior or notifications identifying that the application is within a specific section of the application code.</p>
 * 
 * <p>A message's ID for a given source and type further distinguishes messages within namespaces. For example, an error caused by a negative parameter value
 * or an invalid internal texture format are both errors generated by the API, but would likely have different message IDs.</p>
 * 
 * <p>Each message is also assigned to a severity level that denotes roughly how "important" that message is in comparison to other messages across all
 * sources and types. For example, notification of a GL error would likely have a higher severity than a performance warning due to redundant state changes.</p>
 * 
 * <p>Furthermore, every message contains an implementation-dependent string representation that provides a useful description of the event.</p>
 * 
 * <p>Messages are communicated to the application through an application-defined callback function that is called by the GL implementation on each debug
 * message. The motivation for the callback routine is to free application developers from actively having to query whether a GL error, or any other
 * debuggable event has happened after each call to a GL function. With a callback, developers can keep their code free of debug checks, set breakpoints in
 * the callback function, and only have to react to messages as they occur. In situations where using a callback is not possible, a message log is also
 * provided that stores only copies of recent messages until they are actively queried.</p>
 * 
 * <p>To control the volume of debug output, messages can be disabled either individually by ID, or entire sets of messages can be turned off based on
 * combination of source and type, through the entire application code or only section of the code encapsulated in debug groups. A debug group may also be
 * used to annotate the command stream using descriptive texts.</p>
 * 
 * <p>This extension also defines debug markers, a mechanism for the OpenGL application to annotate the command stream with markers for discrete events.</p>
 * 
 * <p>When profiling or debugging an OpenGL application with a built-in or an external debugger or profiler, it is difficult to relate the commands within the
 * command stream to the elements of the scene or parts of the program code to which they correspond. Debug markers and debug groups help obviate this by
 * allowing applications to specify this link. For example, a debug marker can be used to identify the beginning of a frame in the command stream and a
 * debug group can encapsulate a specific command stream to identify a rendering pass. Debug groups also allow control of the debug outputs volume per
 * section of an application code providing an effective way to handle the massive amount of debug outputs that drivers can generate.</p>
 * 
 * <p>Some existing implementations of {@link ARBDebugOutput ARB_debug_output} only expose the ARB_debug_output extension string if the context was created with the debug
 * flag {GLX|WGL}_CONTEXT_DEBUG_BIT_ARB as specified in {GLX|WGL}_ARB_create_context. The behavior is not obvious when the functionality is brought into
 * the OpenGL core specification because the extension string and function entry points must always exist.</p>
 * 
 * <p>This extension modifies the existing ARB_debug_output extension to allow implementations to always have an empty message log. The specific messages
 * written to the message log or callback routines are already implementation defined, so this specification simply makes it explicit that it's fine for
 * there to be zero messages generated, even when a GL error occurs, which is useful if the context is non-debug.</p>
 * 
 * <p>Debug output can be enabled and disabled by changing the {@link #GL_DEBUG_OUTPUT DEBUG_OUTPUT} state. It is implementation defined how much debug output is generated if the
 * context was created without the {@link #GL_CONTEXT_FLAG_DEBUG_BIT CONTEXT_FLAG_DEBUG_BIT} set. This is a new query bit added to the existing {@link GL30#GL_CONTEXT_FLAGS CONTEXT_FLAGS} state to specify whether the
 * context was created with debug enabled.</p>
 * 
 * <p>Finally, this extension defines a mechanism for OpenGL applications to label their objects (textures, buffers, shaders, etc.) with a descriptive string.</p>
 * 
 * <p>When profiling or debugging an OpenGL application within an external or built-in (debut output API) debugger or profiler it is difficult to identify
 * objects from their object names (integers).</p>
 * 
 * <p>Even when the object itself is viewed it can be problematic to differentiate between similar objects. Attaching a descriptive string, a label, to an
 * object obviates this difficulty.</p>
 * 
 * <p>The intended purpose of this extension is purely to improve the user experience within OpenGL development tools and application built-in profilers and
 * debuggers. This extension typically improves OpenGL programmers efficiency by allowing them to instantly detect issues and the reason for these issues
 * giving him more time to focus on adding new features to an OpenGL application.</p>
 * 
 * <p>Promoted to core in {@link GL43 OpenGL 4.3}.</p>
 */
public final class KHRDebug {

	/** Tokens accepted by the {@code target} parameters of Enable, Disable, and IsEnabled. */
	public static final int
		GL_DEBUG_OUTPUT             = 0x92E0,
		GL_DEBUG_OUTPUT_SYNCHRONOUS = 0x8242;

	/** Returned by GetIntegerv when {@code pname} is CONTEXT_FLAGS. */
	public static final int GL_CONTEXT_FLAG_DEBUG_BIT = 0x2;

	/** Tokens accepted by the {@code value} parameters of GetBooleanv, GetIntegerv, GetFloatv, GetDoublev and GetInteger64v. */
	public static final int
		GL_MAX_DEBUG_MESSAGE_LENGTH         = 0x9143,
		GL_MAX_DEBUG_LOGGED_MESSAGES        = 0x9144,
		GL_DEBUG_LOGGED_MESSAGES            = 0x9145,
		GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = 0x8243,
		GL_MAX_DEBUG_GROUP_STACK_DEPTH      = 0x826C,
		GL_DEBUG_GROUP_STACK_DEPTH          = 0x826D,
		GL_MAX_LABEL_LENGTH                 = 0x82E8;

	/** Tokens accepted by the {@code pname} parameter of GetPointerv. */
	public static final int
		GL_DEBUG_CALLBACK_FUNCTION   = 0x8244,
		GL_DEBUG_CALLBACK_USER_PARAM = 0x8245;

	/**
	 * Tokens accepted or provided by the {@code source} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code sources} parameter
	 * of GetDebugMessageLog (some commands restrict {@code source} to a subset of these parameters; see the specification body for details).
	 */
	public static final int
		GL_DEBUG_SOURCE_API             = 0x8246,
		GL_DEBUG_SOURCE_WINDOW_SYSTEM   = 0x8247,
		GL_DEBUG_SOURCE_SHADER_COMPILER = 0x8248,
		GL_DEBUG_SOURCE_THIRD_PARTY     = 0x8249,
		GL_DEBUG_SOURCE_APPLICATION     = 0x824A,
		GL_DEBUG_SOURCE_OTHER           = 0x824B;

	/**
	 * Tokens accepted or provided by the {@code type} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code types} parameter of
	 * GetDebugMessageLog.
	 */
	public static final int
		GL_DEBUG_TYPE_ERROR               = 0x824C,
		GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR = 0x824D,
		GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR  = 0x824E,
		GL_DEBUG_TYPE_PORTABILITY         = 0x824F,
		GL_DEBUG_TYPE_PERFORMANCE         = 0x8250,
		GL_DEBUG_TYPE_OTHER               = 0x8251,
		GL_DEBUG_TYPE_MARKER              = 0x8268;

	/** Tokens accepted or provided by the {@code type} parameters of DebugMessageControl and DEBUGPROC, and the {@code types} parameter of GetDebugMessageLog. */
	public static final int
		GL_DEBUG_TYPE_PUSH_GROUP = 0x8269,
		GL_DEBUG_TYPE_POP_GROUP  = 0x826A;

	/**
	 * Tokens accepted or provided by the {@code severity} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC callback functions, and the
	 * {@code severities} parameter of GetDebugMessageLog.
	 */
	public static final int
		GL_DEBUG_SEVERITY_HIGH         = 0x9146,
		GL_DEBUG_SEVERITY_MEDIUM       = 0x9147,
		GL_DEBUG_SEVERITY_LOW          = 0x9148,
		GL_DEBUG_SEVERITY_NOTIFICATION = 0x826B;

	/** Tokens accepted or provided by the {@code identifier} parameters of ObjectLabel and GetObjectLabel. */
	public static final int
		GL_BUFFER           = 0x82E0,
		GL_SHADER           = 0x82E1,
		GL_PROGRAM          = 0x82E2,
		GL_QUERY            = 0x82E3,
		GL_PROGRAM_PIPELINE = 0x82E4,
		GL_SAMPLER          = 0x82E6,
		GL_DISPLAY_LIST     = 0x82E7;

	/** Function address. */
	@JavadocExclude
	public final long
		DebugMessageControl,
		DebugMessageInsert,
		DebugMessageCallback,
		GetDebugMessageLog,
		PushDebugGroup,
		PopDebugGroup,
		ObjectLabel,
		GetObjectLabel,
		ObjectPtrLabel,
		GetObjectPtrLabel;

	@JavadocExclude
	public KHRDebug(FunctionProvider provider) {
		DebugMessageControl = provider.getFunctionAddress("glDebugMessageControl");
		DebugMessageInsert = provider.getFunctionAddress("glDebugMessageInsert");
		DebugMessageCallback = provider.getFunctionAddress("glDebugMessageCallback");
		GetDebugMessageLog = provider.getFunctionAddress("glGetDebugMessageLog");
		PushDebugGroup = provider.getFunctionAddress("glPushDebugGroup");
		PopDebugGroup = provider.getFunctionAddress("glPopDebugGroup");
		ObjectLabel = provider.getFunctionAddress("glObjectLabel");
		GetObjectLabel = provider.getFunctionAddress("glGetObjectLabel");
		ObjectPtrLabel = provider.getFunctionAddress("glObjectPtrLabel");
		GetObjectPtrLabel = provider.getFunctionAddress("glGetObjectPtrLabel");
	}

	// --- [ Function Addresses ] ---

	/** Returns the {@link KHRDebug} instance for the current context. */
	public static KHRDebug getInstance() {
		return checkFunctionality(GL.getCapabilities().__KHRDebug);
	}

	static KHRDebug create(java.util.Set<String> ext, FunctionProvider provider) {
		if ( !ext.contains("GL_KHR_debug") ) return null;

		KHRDebug funcs = new KHRDebug(provider);

		boolean supported = checkFunctions(
			funcs.DebugMessageControl, funcs.DebugMessageInsert, funcs.DebugMessageCallback, funcs.GetDebugMessageLog, funcs.PushDebugGroup, 
			funcs.PopDebugGroup, funcs.ObjectLabel, funcs.GetObjectLabel, funcs.ObjectPtrLabel, funcs.GetObjectPtrLabel
		);

		return GL.checkExtension("GL_KHR_debug", funcs, supported);
	}

	// --- [ glDebugMessageControl ] ---

	/** Unsafe version of {@link #glDebugMessageControl DebugMessageControl} */
	@JavadocExclude
	public static void nglDebugMessageControl(int source, int type, int severity, int count, long ids, boolean enabled) {
		long __functionAddress = getInstance().DebugMessageControl;
		invokeIIIIPZV(__functionAddress, source, type, severity, count, ids, enabled);
	}

	/**
	 * Controls the volume of debug output in the active debug group, by disabling specific or groups of messages.
	 * 
	 * <p>If {@code enabled} is {@link GL11#GL_TRUE TRUE}, the referenced subset of messages will be enabled. If {@link GL11#GL_FALSE FALSE}, then those messages will be disabled.</p>
	 * 
	 * <p>This command can reference different subsets of messages by first considering the set of all messages, and filtering out messages based on the following
	 * ways:
	 * <ul>
	 * <li>If {@code source}, {@code type}, or {@code severity} is {@link GL11#GL_DONT_CARE DONT_CARE}, the messages from all sources, of all types, or of all severities are
	 * referenced respectively.</li>
	 * <li>When values other than {@link GL11#GL_DONT_CARE DONT_CARE} are specified, all messages whose source, type, or severity match the specified {@code source}, {@code type},
	 * or {@code severity} respectively will be referenced.</li>
	 * <li>If {@code count} is greater than zero, then {@code ids} is an array of {@code count} message IDs for the specified combination of {@code source} and
	 * {@code type}. In this case, if {@code source} or {@code type} is {@link GL11#GL_DONT_CARE DONT_CARE}, or {@code severity} is not {@link GL11#GL_DONT_CARE DONT_CARE}, the error
	 * {@link GL11#GL_INVALID_OPERATION INVALID_OPERATION} is generated.</li>
	 * </ul></p>
	 * 
	 * <p>Unrecognized message IDs in {@code ids} are ignored. If {@code count} is zero, the value if {@code ids} is ignored.</p>
	 * 
	 * <p>Although messages are grouped into an implicit hierarchy by their sources and types, there is no explicit per-source, per-type or per-severity enabled
	 * state. Instead, the enabled state is stored individually for each message. There is no difference between disabling all messages from one source in a
	 * single call, and individually disabling all messages from that source using their types and IDs.</p>
	 * 
	 * <p>If the {@link #GL_DEBUG_OUTPUT DEBUG_OUTPUT} state is disabled the GL operates the same as if messages of every {@code source}, {@code type} or {@code severity} are disabled.</p>
	 *
	 * @param source   the source of debug messages to enable or disable. One of:<br>{@link #GL_DEBUG_SOURCE_API DEBUG_SOURCE_API}, {@link #GL_DEBUG_SOURCE_WINDOW_SYSTEM DEBUG_SOURCE_WINDOW_SYSTEM}, {@link #GL_DEBUG_SOURCE_SHADER_COMPILER DEBUG_SOURCE_SHADER_COMPILER}, {@link #GL_DEBUG_SOURCE_THIRD_PARTY DEBUG_SOURCE_THIRD_PARTY}, {@link #GL_DEBUG_SOURCE_APPLICATION DEBUG_SOURCE_APPLICATION}, {@link #GL_DEBUG_SOURCE_OTHER DEBUG_SOURCE_OTHER}
	 * @param type     the type of debug messages to enable or disable. One of:<br>{@link #GL_DEBUG_TYPE_ERROR DEBUG_TYPE_ERROR}, {@link #GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR DEBUG_TYPE_DEPRECATED_BEHAVIOR}, {@link #GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR DEBUG_TYPE_UNDEFINED_BEHAVIOR}, {@link #GL_DEBUG_TYPE_PORTABILITY DEBUG_TYPE_PORTABILITY}, {@link #GL_DEBUG_TYPE_PERFORMANCE DEBUG_TYPE_PERFORMANCE}, {@link #GL_DEBUG_TYPE_OTHER DEBUG_TYPE_OTHER}, {@link #GL_DEBUG_TYPE_MARKER DEBUG_TYPE_MARKER}
	 * @param severity the severity of debug messages to enable or disable. One of:<br>{@link #GL_DEBUG_SEVERITY_HIGH DEBUG_SEVERITY_HIGH}, {@link #GL_DEBUG_SEVERITY_MEDIUM DEBUG_SEVERITY_MEDIUM}, {@link #GL_DEBUG_SEVERITY_LOW DEBUG_SEVERITY_LOW}, {@link #GL_DEBUG_SEVERITY_NOTIFICATION DEBUG_SEVERITY_NOTIFICATION}
	 * @param count    the length of the array {@code ids}
	 * @param ids      an array of unsigned integers containing the ids of the messages to enable or disable
	 * @param enabled  whether the selected messages should be enabled or disabled
	 */
	public static void glDebugMessageControl(int source, int type, int severity, int count, ByteBuffer ids, boolean enabled) {
		if ( LWJGLUtil.CHECKS )
			checkBuffer(ids, count << 2);
		GL43.nglDebugMessageControl(source, type, severity, count, memAddress(ids), enabled);
	}

	/** Alternative version of: {@link #glDebugMessageControl DebugMessageControl} */
	public static void glDebugMessageControl(int source, int type, int severity, IntBuffer ids, boolean enabled) {
		GL43.nglDebugMessageControl(source, type, severity, ids.remaining(), memAddress(ids), enabled);
	}

	/** Single value version of: {@link #glDebugMessageControl DebugMessageControl} */
	public static void glDebugMessageControl(int source, int type, int severity, int id, boolean enabled) {
		APIBuffer __buffer = apiBuffer();
		int ids = __buffer.intParam(id);
		GL43.nglDebugMessageControl(source, type, severity, 1, __buffer.address(ids), enabled);
	}

	// --- [ glDebugMessageInsert ] ---

	/** Unsafe version of {@link #glDebugMessageInsert DebugMessageInsert} */
	@JavadocExclude
	public static void nglDebugMessageInsert(int source, int type, int id, int severity, int length, long message) {
		long __functionAddress = getInstance().DebugMessageInsert;
		invokeIIIIIPV(__functionAddress, source, type, id, severity, length, message);
	}

	/**
	 * This function can be called by applications and third-party libraries to generate their own messages, such as ones containing timestamp information or
	 * signals about specific render system events.
	 * 
	 * <p>The value of {@code id} specifies the ID for the message and {@code severity} indicates its severity level as defined by the caller. The string
	 * {@code buf} contains the string representation of the message. The parameter {@code length} contains the number of characters in {@code buf}. If
	 * {@code length} is negative, it is implied that {@code buf} contains a null terminated string. The error {@link GL11#GL_INVALID_VALUE INVALID_VALUE} will be generated if the
	 * number of characters in {@code buf}, excluding the null terminator when {@code length} is negative, is not less than the value of
	 * {@link #GL_MAX_DEBUG_MESSAGE_LENGTH MAX_DEBUG_MESSAGE_LENGTH}.</p>
	 * 
	 * <p>If the {@link #GL_DEBUG_OUTPUT DEBUG_OUTPUT} state is disabled calls to DebugMessageInsert are discarded and do not generate an error.</p>
	 *
	 * @param source   the source of the debug message to insert. One of:<br>{@link #GL_DEBUG_SOURCE_API DEBUG_SOURCE_API}, {@link #GL_DEBUG_SOURCE_WINDOW_SYSTEM DEBUG_SOURCE_WINDOW_SYSTEM}, {@link #GL_DEBUG_SOURCE_SHADER_COMPILER DEBUG_SOURCE_SHADER_COMPILER}, {@link #GL_DEBUG_SOURCE_THIRD_PARTY DEBUG_SOURCE_THIRD_PARTY}, {@link #GL_DEBUG_SOURCE_APPLICATION DEBUG_SOURCE_APPLICATION}, {@link #GL_DEBUG_SOURCE_OTHER DEBUG_SOURCE_OTHER}
	 * @param type     the type of the debug message insert. One of:<br>{@link #GL_DEBUG_TYPE_ERROR DEBUG_TYPE_ERROR}, {@link #GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR DEBUG_TYPE_DEPRECATED_BEHAVIOR}, {@link #GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR DEBUG_TYPE_UNDEFINED_BEHAVIOR}, {@link #GL_DEBUG_TYPE_PORTABILITY DEBUG_TYPE_PORTABILITY}, {@link #GL_DEBUG_TYPE_PERFORMANCE DEBUG_TYPE_PERFORMANCE}, {@link #GL_DEBUG_TYPE_OTHER DEBUG_TYPE_OTHER}, {@link #GL_DEBUG_TYPE_MARKER DEBUG_TYPE_MARKER}
	 * @param id       the user-supplied identifier of the message to insert. One of:<br>{@link #GL_DEBUG_SEVERITY_HIGH DEBUG_SEVERITY_HIGH}, {@link #GL_DEBUG_SEVERITY_MEDIUM DEBUG_SEVERITY_MEDIUM}, {@link #GL_DEBUG_SEVERITY_LOW DEBUG_SEVERITY_LOW}, {@link #GL_DEBUG_SEVERITY_NOTIFICATION DEBUG_SEVERITY_NOTIFICATION}
	 * @param severity the severity of the debug messages to insert
	 * @param length   the length of the string contained in the character array whose address is given by {@code message}
	 * @param message  a character array containing the message to insert
	 */
	public static void glDebugMessageInsert(int source, int type, int id, int severity, int length, ByteBuffer message) {
		if ( LWJGLUtil.CHECKS )
			checkBuffer(message, length);
		GL43.nglDebugMessageInsert(source, type, id, severity, length, memAddress(message));
	}

	/** Alternative version of: {@link #glDebugMessageInsert DebugMessageInsert} */
	public static void glDebugMessageInsert(int source, int type, int id, int severity, ByteBuffer message) {
		GL43.nglDebugMessageInsert(source, type, id, severity, message.remaining(), memAddress(message));
	}

	/** CharSequence version of: {@link #glDebugMessageInsert DebugMessageInsert} */
	public static void glDebugMessageInsert(int source, int type, int id, int severity, CharSequence message) {
		APIBuffer __buffer = apiBuffer();
		int messageEncoded = __buffer.stringParamUTF8(message, false);
		int messageEncodedLen = __buffer.getOffset() - messageEncoded;
		GL43.nglDebugMessageInsert(source, type, id, severity, messageEncodedLen, __buffer.address(messageEncoded));
	}

	// --- [ glDebugMessageCallback ] ---

	/**
	 * Specifies a callback to receive debugging messages from the GL.
	 * 
	 * <p>The function's prototype must follow the type definition of DEBUGPROC including its platform-dependent calling convention. Anything else will result in
	 * undefined behavior. Only one debug callback can be specified for the current context, and further calls overwrite the previous callback. Specifying
	 * {@code NULL} as the value of {@code callback} clears the current callback and disables message output through callbacks. Applications can provide
	 * user-specified data through the pointer {@code userParam}. The context will store this pointer and will include it as one of the parameters in each call
	 * to the callback function.</p>
	 * 
	 * <p>If the application has specified a callback function for receiving debug output, the implementation will call that function whenever any enabled message
	 * is generated.  The source, type, ID, and severity of the message are specified by the DEBUGPROC parameters {@code source}, {@code type}, {@code id}, and
	 * {@code severity}, respectively. The string representation of the message is stored in {@code message} and its length (excluding the null-terminator) is
	 * stored in {@code length}. The parameter {@code userParam} is the user-specified parameter that was given when calling DebugMessageCallback.</p>
	 * 
	 * <p>Applications can query the current callback function and the current user-specified parameter by obtaining the values of {@link #GL_DEBUG_CALLBACK_FUNCTION DEBUG_CALLBACK_FUNCTION} and
	 * {@link #GL_DEBUG_CALLBACK_USER_PARAM DEBUG_CALLBACK_USER_PARAM}, respectively.</p>
	 * 
	 * <p>Applications that specify a callback function must be aware of certain special conditions when executing code inside a callback when it is called by the
	 * GL, regardless of the debug source.</p>
	 * 
	 * <p>The memory for {@code message} is owned and managed by the GL, and should only be considered valid for the duration of the function call.</p>
	 * 
	 * <p>The behavior of calling any GL or window system function from within the callback function is undefined and may lead to program termination.</p>
	 * 
	 * <p>Care must also be taken in securing debug callbacks for use with asynchronous debug output by multi-threaded GL implementations.</p>
	 * 
	 * <p>If the {@link #GL_DEBUG_OUTPUT DEBUG_OUTPUT} state is disabled then the GL will not call the callback function.</p>
	 *
	 * @param callback  a callback function that will be called when a debug message is generated
	 * @param userParam a user supplied pointer that will be passed on each invocation of {@code callback}
	 */
	public static void glDebugMessageCallback(GLDebugMessageCallback callback, long userParam) {
		long __functionAddress = getInstance().DebugMessageCallback;
		invokePPV(__functionAddress, callback == null ? NULL : callback.getPointer(), userParam);
	}

	// --- [ glGetDebugMessageLog ] ---

	/** Unsafe version of {@link #glGetDebugMessageLog GetDebugMessageLog} */
	@JavadocExclude
	public static int nglGetDebugMessageLog(int count, int bufsize, long sources, long types, long ids, long severities, long lengths, long messageLog) {
		long __functionAddress = getInstance().GetDebugMessageLog;
		return invokeIIPPPPPPI(__functionAddress, count, bufsize, sources, types, ids, severities, lengths, messageLog);
	}

	/**
	 * Retrieves messages from the debug message log.
	 * 
	 * <p>This function fetches a maximum of <count> messages from the message log, and will return the number of messages successfully fetched.</p>
	 * 
	 * <p>Messages will be fetched from the log in order of oldest to newest. Those messages that were fetched will be removed from the log.</p>
	 * 
	 * <p>The sources, types, severities, IDs, and string lengths of fetched messages will be stored in the application-provided arrays {@code sources},
	 * {@code types}, {@code severities}, {@code ids}, and {@code lengths}, respectively. The application is responsible for allocating enough space for each
	 * array to hold up to {@code count} elements. The string representations of all fetched messages are stored in the {@code messageLog} array. If multiple
	 * messages are fetched, their strings are concatenated into the same {@code messageLog} array and will be separated by single null terminators. The last
	 * string in the array will also be null-terminated. The maximum size of {@code messageLog}, including the space used by all null terminators, is given by
	 * {@code bufSize}. If {@code bufSize} is less than zero and {@code messageLog} is not {@code NULL}, an {@link GL11#GL_INVALID_VALUE INVALID_VALUE} error will be generated. If a message's
	 * string, including its null terminator, can not fully fit within the {@code messageLog} array's remaining space, then that message and any subsequent
	 * messages will not be fetched and will remain in the log. The string lengths stored in the array {@code lengths} include the space for the null terminator of each string.</p>
	 * 
	 * <p>Any or all of the arrays {@code sources}, {@code types}, {@code ids}, {@code severities}, {@code lengths} and {@code messageLog} can also be null
	 * pointers, which causes the attributes for such arrays to be discarded when messages are fetched, however those messages will still be removed from the
	 * log. Thus to simply delete up to {@code count} messages from the message log while ignoring their attributes, the application can call the function with
	 * null pointers for all attribute arrays.</p>
	 * 
	 * <p>If the context was created without the {@link #GL_CONTEXT_FLAG_DEBUG_BIT CONTEXT_FLAG_DEBUG_BIT} in the {@link GL30#GL_CONTEXT_FLAGS CONTEXT_FLAGS} state, then the GL can opt to never add messages to the message
	 * log so GetDebugMessageLog will always return zero.</p>
	 *
	 * @param count      the number of debug messages to retrieve from the log
	 * @param bufsize    the size of the buffer whose address is given by {@code messageLog}
	 * @param sources    an array of variables to receive the sources of the retrieved messages
	 * @param types      an array of variables to receive the types of the retrieved messages
	 * @param ids        an array of unsigned integers to receive the ids of the retrieved messages
	 * @param severities an array of variables to receive the severites of the retrieved messages
	 * @param lengths    an array of variables to receive the lengths of the received messages
	 * @param messageLog an array of characters that will receive the messages
	 */
	public static int glGetDebugMessageLog(int count, int bufsize, ByteBuffer sources, ByteBuffer types, ByteBuffer ids, ByteBuffer severities, ByteBuffer lengths, ByteBuffer messageLog) {
		if ( LWJGLUtil.CHECKS ) {
			if ( messageLog != null ) checkBuffer(messageLog, bufsize);
			if ( sources != null ) checkBuffer(sources, count << 2);
			if ( types != null ) checkBuffer(types, count << 2);
			if ( ids != null ) checkBuffer(ids, count << 2);
			if ( severities != null ) checkBuffer(severities, count << 2);
			if ( lengths != null ) checkBuffer(lengths, count << 2);
		}
		return GL43.nglGetDebugMessageLog(count, bufsize, memAddressSafe(sources), memAddressSafe(types), memAddressSafe(ids), memAddressSafe(severities), memAddressSafe(lengths), memAddressSafe(messageLog));
	}

	/** Alternative version of: {@link #glGetDebugMessageLog GetDebugMessageLog} */
	public static int glGetDebugMessageLog(int count, IntBuffer sources, IntBuffer types, IntBuffer ids, IntBuffer severities, IntBuffer lengths, ByteBuffer messageLog) {
		if ( LWJGLUtil.CHECKS ) {
			if ( sources != null ) checkBuffer(sources, count);
			if ( types != null ) checkBuffer(types, count);
			if ( ids != null ) checkBuffer(ids, count);
			if ( severities != null ) checkBuffer(severities, count);
			if ( lengths != null ) checkBuffer(lengths, count);
		}
		return GL43.nglGetDebugMessageLog(count, messageLog == null ? 0 : messageLog.remaining(), memAddressSafe(sources), memAddressSafe(types), memAddressSafe(ids), memAddressSafe(severities), memAddressSafe(lengths), memAddressSafe(messageLog));
	}

	// --- [ glPushDebugGroup ] ---

	/** Unsafe version of {@link #glPushDebugGroup PushDebugGroup} */
	@JavadocExclude
	public static void nglPushDebugGroup(int source, int id, int length, long message) {
		long __functionAddress = getInstance().PushDebugGroup;
		invokeIIIPV(__functionAddress, source, id, length, message);
	}

	/**
	 * Pushes a debug group described by the string {@code message} into the command stream. The value of {@code id} specifies the ID of messages generated.
	 * The parameter {@code length} contains the number of characters in {@code message}. If {@code length} is negative, it is implied that {@code message}
	 * contains a null terminated string. The message has the specified {@code source} and {@code id}, {@code type} {@link #GL_DEBUG_TYPE_PUSH_GROUP DEBUG_TYPE_PUSH_GROUP}, and
	 * {@code severity} {@link #GL_DEBUG_SEVERITY_NOTIFICATION DEBUG_SEVERITY_NOTIFICATION}. The GL will put a new debug group on top of the debug group stack which inherits the control of the
	 * volume of debug output of the debug group previously residing on the top of the debug group stack. Because debug groups are strictly hierarchical, any
	 * additional control of the debug output volume will only apply within the active debug group and the debug groups pushed on top of the active debug group.
	 * 
	 * <p>An {@link GL11#GL_INVALID_ENUM INVALID_ENUM} error is generated if the value of {@code source} is neither {@link #GL_DEBUG_SOURCE_APPLICATION DEBUG_SOURCE_APPLICATION} nor {@link #GL_DEBUG_SOURCE_THIRD_PARTY DEBUG_SOURCE_THIRD_PARTY}. An
	 * {@link GL11#GL_INVALID_VALUE INVALID_VALUE} error is generated if {@code length} is negative and the number of characters in {@code message}, excluding the null-terminator, is
	 * not less than the value of {@link #GL_MAX_DEBUG_MESSAGE_LENGTH MAX_DEBUG_MESSAGE_LENGTH}.</p>
	 *
	 * @param source  the source of the debug message. One of:<br>{@link #GL_DEBUG_SOURCE_APPLICATION DEBUG_SOURCE_APPLICATION}, {@link #GL_DEBUG_SOURCE_THIRD_PARTY DEBUG_SOURCE_THIRD_PARTY}
	 * @param id      the identifier of the message
	 * @param length  the length of the message to be sent to the debug output stream
	 * @param message a string containing the message to be sent to the debug output stream
	 */
	public static void glPushDebugGroup(int source, int id, int length, ByteBuffer message) {
		if ( LWJGLUtil.CHECKS )
			checkBuffer(message, length);
		GL43.nglPushDebugGroup(source, id, length, memAddress(message));
	}

	/** Alternative version of: {@link #glPushDebugGroup PushDebugGroup} */
	public static void glPushDebugGroup(int source, int id, ByteBuffer message) {
		GL43.nglPushDebugGroup(source, id, message.remaining(), memAddress(message));
	}

	/** CharSequence version of: {@link #glPushDebugGroup PushDebugGroup} */
	public static void glPushDebugGroup(int source, int id, CharSequence message) {
		APIBuffer __buffer = apiBuffer();
		int messageEncoded = __buffer.stringParamUTF8(message, false);
		int messageEncodedLen = __buffer.getOffset() - messageEncoded;
		GL43.nglPushDebugGroup(source, id, messageEncodedLen, __buffer.address(messageEncoded));
	}

	// --- [ glPopDebugGroup ] ---

	/**
	 * Pops the active debug group. When a debug group is popped, the GL will also generate a debug output message describing its cause based on the
	 * {@code message} string, the source {@code source}, and an ID {@code id} submitted to the associated {@link #glPushDebugGroup PushDebugGroup} command. {@link #GL_DEBUG_TYPE_PUSH_GROUP DEBUG_TYPE_PUSH_GROUP}
	 * and {@link #GL_DEBUG_TYPE_POP_GROUP DEBUG_TYPE_POP_GROUP} share a single namespace for message {@code id}. {@code severity} has the value {@link #GL_DEBUG_SEVERITY_NOTIFICATION DEBUG_SEVERITY_NOTIFICATION}. The {@code type}
	 * has the value {@link #GL_DEBUG_TYPE_POP_GROUP DEBUG_TYPE_POP_GROUP}. Popping a debug group restores the debug output volume control of the parent debug group.
	 * 
	 * <p>Attempting to pop the default debug group off the stack generates a {@link GL11#GL_STACK_UNDERFLOW STACK_UNDERFLOW} error; pushing a debug group onto a stack containing
	 * {@link #GL_MAX_DEBUG_GROUP_STACK_DEPTH MAX_DEBUG_GROUP_STACK_DEPTH} minus one elements will generate a {@link GL11#GL_STACK_OVERFLOW STACK_OVERFLOW} error.</p>
	 */
	public static void glPopDebugGroup() {
		long __functionAddress = getInstance().PopDebugGroup;
		invokeV(__functionAddress);
	}

	// --- [ glObjectLabel ] ---

	/** Unsafe version of {@link #glObjectLabel ObjectLabel} */
	@JavadocExclude
	public static void nglObjectLabel(int identifier, int name, int length, long label) {
		long __functionAddress = getInstance().ObjectLabel;
		invokeIIIPV(__functionAddress, identifier, name, length, label);
	}

	/**
	 * Labels a named object identified within a namespace.
	 *
	 * @param identifier the namespace from which the name of the object is allocated. One of:<br>{@link #GL_BUFFER BUFFER}, {@link #GL_SHADER SHADER}, {@link #GL_PROGRAM PROGRAM}, {@link #GL_QUERY QUERY}, {@link #GL_PROGRAM_PIPELINE PROGRAM_PIPELINE}, {@link #GL_SAMPLER SAMPLER}, {@link #GL_DISPLAY_LIST DISPLAY_LIST}, {@link GL11#GL_VERTEX_ARRAY VERTEX_ARRAY}, {@link GL11#GL_TEXTURE TEXTURE}, {@link GL30#GL_RENDERBUFFER RENDERBUFFER}, {@link GL30#GL_FRAMEBUFFER FRAMEBUFFER}, {@link GL40#GL_TRANSFORM_FEEDBACK TRANSFORM_FEEDBACK}
	 * @param name       the name of the object to label
	 * @param length     the length of the label to be used for the object
	 * @param label      a string containing the label to assign to the object
	 */
	public static void glObjectLabel(int identifier, int name, int length, ByteBuffer label) {
		if ( LWJGLUtil.CHECKS )
			checkBuffer(label, length);
		GL43.nglObjectLabel(identifier, name, length, memAddress(label));
	}

	/** Alternative version of: {@link #glObjectLabel ObjectLabel} */
	public static void glObjectLabel(int identifier, int name, ByteBuffer label) {
		GL43.nglObjectLabel(identifier, name, label.remaining(), memAddress(label));
	}

	/** CharSequence version of: {@link #glObjectLabel ObjectLabel} */
	public static void glObjectLabel(int identifier, int name, CharSequence label) {
		APIBuffer __buffer = apiBuffer();
		int labelEncoded = __buffer.stringParamUTF8(label, false);
		int labelEncodedLen = __buffer.getOffset() - labelEncoded;
		GL43.nglObjectLabel(identifier, name, labelEncodedLen, __buffer.address(labelEncoded));
	}

	// --- [ glGetObjectLabel ] ---

	/** Unsafe version of {@link #glGetObjectLabel GetObjectLabel} */
	@JavadocExclude
	public static void nglGetObjectLabel(int identifier, int name, int bufSize, long length, long label) {
		long __functionAddress = getInstance().GetObjectLabel;
		invokeIIIPPV(__functionAddress, identifier, name, bufSize, length, label);
	}

	/**
	 * Retrieves the label of a named object identified within a namespace.
	 *
	 * @param identifier the namespace from which the name of the object is allocated. One of:<br>{@link #GL_BUFFER BUFFER}, {@link #GL_SHADER SHADER}, {@link #GL_PROGRAM PROGRAM}, {@link #GL_QUERY QUERY}, {@link #GL_PROGRAM_PIPELINE PROGRAM_PIPELINE}, {@link #GL_SAMPLER SAMPLER}, {@link #GL_DISPLAY_LIST DISPLAY_LIST}, {@link GL11#GL_VERTEX_ARRAY VERTEX_ARRAY}, {@link GL11#GL_TEXTURE TEXTURE}, {@link GL30#GL_RENDERBUFFER RENDERBUFFER}, {@link GL30#GL_FRAMEBUFFER FRAMEBUFFER}, {@link GL40#GL_TRANSFORM_FEEDBACK TRANSFORM_FEEDBACK}
	 * @param name       the name of the object whose label to retrieve
	 * @param bufSize    the length of the buffer whose address is in {@code label}
	 * @param length     the address of a variable to receive the length of the object label
	 * @param label      a string that will receive the object label
	 */
	public static void glGetObjectLabel(int identifier, int name, int bufSize, ByteBuffer length, ByteBuffer label) {
		if ( LWJGLUtil.CHECKS ) {
			checkBuffer(label, bufSize);
			if ( length != null ) checkBuffer(length, 1 << 2);
		}
		GL43.nglGetObjectLabel(identifier, name, bufSize, memAddressSafe(length), memAddress(label));
	}

	/** Alternative version of: {@link #glGetObjectLabel GetObjectLabel} */
	public static void glGetObjectLabel(int identifier, int name, IntBuffer length, ByteBuffer label) {
		if ( LWJGLUtil.CHECKS )
			if ( length != null ) checkBuffer(length, 1);
		GL43.nglGetObjectLabel(identifier, name, label.remaining(), memAddressSafe(length), memAddress(label));
	}

	/** String return version of: {@link #glGetObjectLabel GetObjectLabel} */
	public static String glGetObjectLabel(int identifier, int name, int bufSize) {
		APIBuffer __buffer = apiBuffer();
		int length = __buffer.intParam();
		int label = __buffer.bufferParam(bufSize);
		GL43.nglGetObjectLabel(identifier, name, bufSize, __buffer.address(length), __buffer.address(label));
		return memDecodeUTF8(__buffer.buffer(), __buffer.intValue(length), label);
	}

	/** String return (w/ implicit max length) version of: {@link #glGetObjectLabel GetObjectLabel} */
	public static String glGetObjectLabel(int identifier, int name) {
		int bufSize = GL11.glGetInteger(GL_MAX_LABEL_LENGTH);
		APIBuffer __buffer = apiBuffer();
		int length = __buffer.intParam();
		int label = __buffer.bufferParam(bufSize);
		GL43.nglGetObjectLabel(identifier, name, bufSize, __buffer.address(length), __buffer.address(label));
		return memDecodeUTF8(__buffer.buffer(), __buffer.intValue(length), label);
	}

	// --- [ glObjectPtrLabel ] ---

	/** Unsafe version of {@link #glObjectPtrLabel ObjectPtrLabel} */
	@JavadocExclude
	public static void nglObjectPtrLabel(long ptr, int length, long label) {
		long __functionAddress = getInstance().ObjectPtrLabel;
		if ( LWJGLUtil.CHECKS )
			checkPointer(ptr);
		invokePIPV(__functionAddress, ptr, length, label);
	}

	/**
	 * Labels a sync object identified by a pointer.
	 *
	 * @param ptr    a pointer identifying a sync object
	 * @param length the length of the label to be used for the object
	 * @param label  a string containing the label to assign to the object
	 */
	public static void glObjectPtrLabel(long ptr, int length, ByteBuffer label) {
		if ( LWJGLUtil.CHECKS )
			checkBuffer(label, length);
		GL43.nglObjectPtrLabel(ptr, length, memAddress(label));
	}

	/** Alternative version of: {@link #glObjectPtrLabel ObjectPtrLabel} */
	public static void glObjectPtrLabel(long ptr, ByteBuffer label) {
		GL43.nglObjectPtrLabel(ptr, label.remaining(), memAddress(label));
	}

	/** CharSequence version of: {@link #glObjectPtrLabel ObjectPtrLabel} */
	public static void glObjectPtrLabel(long ptr, CharSequence label) {
		APIBuffer __buffer = apiBuffer();
		int labelEncoded = __buffer.stringParamUTF8(label, false);
		int labelEncodedLen = __buffer.getOffset() - labelEncoded;
		GL43.nglObjectPtrLabel(ptr, labelEncodedLen, __buffer.address(labelEncoded));
	}

	// --- [ glGetObjectPtrLabel ] ---

	/** Unsafe version of {@link #glGetObjectPtrLabel GetObjectPtrLabel} */
	@JavadocExclude
	public static void nglGetObjectPtrLabel(long ptr, int bufSize, long length, long label) {
		long __functionAddress = getInstance().GetObjectPtrLabel;
		if ( LWJGLUtil.CHECKS )
			checkPointer(ptr);
		invokePIPPV(__functionAddress, ptr, bufSize, length, label);
	}

	/**
	 * Retrieves the label of a sync object identified by a pointer.
	 *
	 * @param ptr     the name of the sync object whose label to retrieve
	 * @param bufSize the length of the buffer whose address is in {@code label}
	 * @param length  a variable to receive the length of the object label
	 * @param label   a string that will receive the object label
	 */
	public static void glGetObjectPtrLabel(long ptr, int bufSize, ByteBuffer length, ByteBuffer label) {
		if ( LWJGLUtil.CHECKS ) {
			checkBuffer(label, bufSize);
			if ( length != null ) checkBuffer(length, 1 << 2);
		}
		GL43.nglGetObjectPtrLabel(ptr, bufSize, memAddressSafe(length), memAddress(label));
	}

	/** Alternative version of: {@link #glGetObjectPtrLabel GetObjectPtrLabel} */
	public static void glGetObjectPtrLabel(long ptr, IntBuffer length, ByteBuffer label) {
		if ( LWJGLUtil.CHECKS )
			if ( length != null ) checkBuffer(length, 1);
		GL43.nglGetObjectPtrLabel(ptr, label.remaining(), memAddressSafe(length), memAddress(label));
	}

	/** String return version of: {@link #glGetObjectPtrLabel GetObjectPtrLabel} */
	public static String glGetObjectPtrLabel(long ptr, int bufSize) {
		APIBuffer __buffer = apiBuffer();
		int length = __buffer.intParam();
		int label = __buffer.bufferParam(bufSize);
		GL43.nglGetObjectPtrLabel(ptr, bufSize, __buffer.address(length), __buffer.address(label));
		return memDecodeUTF8(__buffer.buffer(), __buffer.intValue(length), label);
	}

	/** String return (w/ implicit max length) version of: {@link #glGetObjectPtrLabel GetObjectPtrLabel} */
	public static String glGetObjectPtrLabel(long ptr) {
		int bufSize = GL11.glGetInteger(GL_MAX_LABEL_LENGTH);
		APIBuffer __buffer = apiBuffer();
		int length = __buffer.intParam();
		int label = __buffer.bufferParam(bufSize);
		GL43.nglGetObjectPtrLabel(ptr, bufSize, __buffer.address(length), __buffer.address(label));
		return memDecodeUTF8(__buffer.buffer(), __buffer.intValue(length), label);
	}

     /**
	 * Creates a {@link GLDebugMessageCallback} that delegates the callback to the specified functional interface.
	 *
	 * @param sam the delegation target
	 *
	 * @return the {@link GLDebugMessageCallback} instance
	 */
	public static GLDebugMessageCallback GLDebugMessageCallback(final GLDebugMessageCallback.SAM sam) {
		return new GLDebugMessageCallback() {
			@Override
			public void invoke(int source, int type, int id, int severity, int length, long message, long userParam) {
				sam.invoke(source, type, id, severity, length, message, userParam);
			}
		};
	}

}